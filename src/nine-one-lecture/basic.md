基础不意味着简单，有时候一道困难的题目也背后的算法也可能是基础算法。 因此我们需要做的是**熟悉各种基础数据结构和算法**，做到融会贯通，举一反三，这样面对复杂问题才能迎刄有余。

比如枚举其实就是一个最最基础的技能，但是枚举却一定和你想象的一样简单。

## 枚举

枚举简单来说就是指尝试所有可能的情况。是最基本的算法。比如枚举一个数组的所有项。

```java
for(int i = 0;i < A.length();i++) {
    // 打印 A[i]
}

```

实际上枚举也可以很复杂。比如维度的上升（枚举 3 维数组），方向的选择（从前往后还是从后往前）等。因此同样是枚举，不同的枚举策略可能有不同的结果和效率。关于这点，我们将在后面的剪枝专题给大家做更多介绍。

枚举有三个东西需要考虑。

1. 状态。都有哪些状态需要我们枚举？
2. 不重不漏。如何枚举才不会重复，且不会漏过正确解？
3. 效率。采取怎么样的枚举策略可以最大化提供算法效果？

比如需要枚举一个集合 S 的所有子集，你会如何做？

1. 状态。我们可以用一个和 S 相同大小的数组 picked 记录每个数被选取的信息， 用 0 表示没有选取，用 1 表示选取。

比如 S 大小为 3， picked 数组 [1,1,0]，表示 S 中的第一项和第二项被选择（索引从 1 开始）。如果 S 的大小为 n，就需要用一个长度为 n 的数组来存储，那么就有 $2^n$ 种状态。

由于数组的值**不是 0 就是 1，满足二值性**，因此更多时候我们会使用**一个数字** y 来表示状态，而不是上面的 picked 数组。其中 y 的**二进制位**对应上面提到的 picked 数组中的一项。

2. 不重不漏。

实际上，我们也可用另外一个数 x 来模拟集合 S。这样问题就转化为两个数（x 和 y）的位运算。

由于我们使用 1 表示被选取， 0 表示选取。因此 如果 x 对应位为 0，其实 y 也只能是 0，而如果 x 对应位是 1，y 却可能是 0 或者 1。也就是说 y 一定小于等于 x， 因此可以枚举所有小于等于 x 的数的二进制，并逐个**判断其是否真的是 x 的子集**。

令 n 为 x 的二进制位数，我们可以写出如下代码。

```js
// 外层枚举所有小于等于 x 的数
ans = [];
for (i = 1; i < 1 << n; i++) {
  if ((x | i) === x) ans.push(i);
}
// ans 就是所有非空子集
```

这种算法的复杂度大约是 $O(4^n)$，也就是说和 x 成正比。这种算法 n 最多取到 12 左右。

这样做不重不漏么？答案是可以的。因为 (x | i) === x 就是 i 是 x 的子集的充要条件。

如果二进制你不好理解，其实你可以转化为十进制理解。比如我给你一个数 132，让你找 132 的子集，这里的子集我简单定义为当前位的数字是否小于等于原数字当前位的数字。这样我们就可以先从 1 枚举到 132，因为这些数潜在都可能是 132 的子集。如果我枚举了一个数字 030，由于 0 小于等于 1，3 小于等于 3，0 小于等于 2，因此 030 是 132 的子集。而如果我枚举了一个数字 040，由于 4 大于 3，因此 040 不是 132 的子集。

3. 效率。

上面的枚举方法虽然也可保证不重不漏，但是却不是最优的，这里介绍一种更好的枚举方法。

具体做法就是$x_i$和 x 进行&（与）运算。与运算可以快速跳到下一个子集。

```js
ans = [];
// 外层枚举所有小于等于 x 的数
for (i = x; i != 0; i = (i - 1) & x) {
  ans.push(i);
}
// ans 就是所有非空子集
```

这样做不重不漏么？算法的关键在于 `i = (i - 1) & x`。这个操作首先将 i - 1，从而把 i 最右边的 1 变成了 0，然后把这位之后的所有 0 变成了 1。经过这样的处理再与 x 求与，就保证了得到的结果是 x 的子集，并且一定是所有子集中小于 i 的最大的一个。直观来看就是倒序枚举除了所有非空子集。

对于有 n 个 1 的二进制数字，需要 $2^n$ 的时间复杂度。而有 n 个 1 的二进制数字有 $C(n,i)$ 个，所以这段代码的时间复杂度为 $\sum_{i=0}^{n} C(n,i)\times2^i$，大约是 $O(3^n)$。和上面一样，这种算法的时间复杂度也和 x 成正比。但是这种算法 n 最多取到 15 左右。

这种方法对题目有一定要求， 即：

1. 数据范围要合适，否则数字无法表示了。
2. 只能有两种状态，这样才可以用二进制位 0 和 1 进行模拟。

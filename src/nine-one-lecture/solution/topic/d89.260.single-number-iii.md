# 260. 只出现一次的数字 III

## 题目地址

[https://leetcode-cn.com/problems/single-number-iii/](https://leetcode-cn.com/problems/single-number-iii/)

## 题目描述

```java
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

示例 :

输入: [1,2,1,3,2,5]
输出: [3,5]
注意：

结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
```

## 前置知识

- 位运算
- 数组
- 哈希表

## 分析

这个题可以很直观的用哈希表来做，遍历一遍数组存入哈希表，再遍历一遍key，找到value为1的那两个数就是最后答案，该解决方案的时间复杂度是线性，但是空间复杂度是$O(keys)$，不符合题意。

其实做过该系列的前两道题的应该都知道，本题可以巧用位运算的方式来实现$O(1)$空间复杂度，再具体来说使用到了异或(xor)的性质(这个要多做题总结，而不是第一眼看到题就能想出来用位运算)。

首先来再复习一下xor的主要性质

```python
0 xor 1 = 1    0 xor 0 = 0
1 xor 1 = 0    1 xor 0 = 1
也就是说当比较的两个bit不同时，xor的结果才为1

a xor b = b xor a  满足交换律
a xor a = 0        与自身异或为0
```

也就是说，如果两个数相同那么必定xor没了，而该题说只有两个数出现一次，其他都是两次，再利用0 xor 1 = 1 这条，可得如下解法：

- 将nums中所有数异或起来得到数x，x必定不为0，因为相同的两个数都约掉了，相当于那两个只出现了一次的数进行xor。
- 随便找一个x的bit为1的位置，为1就代表这两个出现一次的数在该位置的bit不同。
- 这样就可以根据这个为1的bit位来将原问题分解为两个子问题，子问题的定义是：给定一个数组，该数组只有一个数出现一次，其他数都出现两次。
- 这样就转换为基本的找出只出现一次数的问题了，直接将这个数组所有元素xor起来得到的就是答案。
- 为方便求解，本题使用的是低位最早出现1的位置。

## 代码：

### Java

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        
        int xor = 0;
        for (int i : nums)
            xor ^= i;
        
        int mask = 1;
        while ((mask & xor) == 0)
            mask <<= 1;

        int[] res = new int[2];
        for (int i : nums) {
            
            if ((i & mask) == 0)
                res[0] ^= i;
            else
                res[1] ^= i;
        }
        return res;
    }
}
```

### 复杂度分析

设：$N$个数

时间复杂度：$O(N)$

空间复杂度：$O(1)$

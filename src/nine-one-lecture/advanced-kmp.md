# 字符串匹配专题

字符串匹配算法（String matching algorithms）是字符串问题下的一个搜索问题，用来在一长字符串或文章中，找出其是否包含某一个或多个字符串以及其位置的算法。该算法的应用非常广泛，比如：生物基因匹配、信息检索等。

用数学语言描述如下:

假设$T$是一个长度为$n$的文本串，$P$是长度为$m$的模式串。如果有 $0<=s<n-m$，使得$T[s, s+1,...,s+m]$等于$P$，则称$P$在$T$中出现且位移为$s$。

<!-- 字符串匹配的概念 -->

## 暴力(BF)

**核心思路**

在日常编码生活中，我们肯定会遇到类似的问题，大部分数据量其实**不大**，串长也**较短**，因此自然会想到**窗口大小固定的滑动窗口**找出所有子串并依次和模式串按字母顺序依次比对看是否匹配并记录。该方法可以抽象为以下几步：

- 非法情况处理，如模式串长度大于待匹配串等（防御性编程）
- 初始化大小为模式串长的滑窗
- 固定当前窗口，将当前窗口的子串与模式串匹配,若匹配成功，则记录相关信息，如该位置下标
- 窗口向后移动一格

**伪代码**

```python
n = length[T]
m = length[P]

for s = 0 to n - m
  do if T[s..s+m] == P
    save info
```

时间复杂度 $O(n * m)$, 空间复杂度 $O(1)$

这种暴力算法对于数据规模小，串短的问题已经足够了，但是很多场景下数据规模很大，那暴力算法就显得捉襟见肘了，毕竟时间复杂度摆在那里，响应时间过长。我们稍加分析其实不难发现，我们在每次窗口后移一位进行匹配的时候，实际上是把上一个窗口的所有状态信息全部都丢掉不要了，这会造成信息的浪费，那么都有哪些常见且优秀的解决方案呢？

## Rabin-Karp 算法(RK)

**核心思路**

RK 算法主要是对$T$中每个长度为$m$的子字符串$T[s..s+m]$进行 hash 运算，生成 hash 值$h1$，对$P$进行 hash 运算，生成 hash 值$h2$, 比对$h1$和$h2$，如果两个 hash 值(不考虑冲突)相等，则判断$P$在$T$中出现，且位移为$s$。

该方法和 BF 主要步骤是一样的，如果每步都算子串的 hash 值，那么每步 hash 的时间复杂度为$O(m)$，那么最后的整体复杂度和 BF 一样都为$O(m*n)$。RK 算法妙在滑动窗口的时候，设计了一个适合的哈希函数，有效保留了上一个状态的部分信息，这样第一次计算子串 hash 值时间复杂度为$O(m)$，而后续就可以达到$O(1)$，最终的时间复杂度就降为$O(m+n)$。该方法可以抽象为以下几步：

- 非法情况处理，如模式串长度大于待匹配串等（防御性编程）
- 计算出模式串 hash 值
- 初始化大小为模式串长的滑窗并计算出 hash 值
- 判断当前 hash 值是否和模式串 hash 值相等，若相等，则记录相关信息，如该位置下标
- 窗口向后移动一格，并再次计算 hash 值（此处利用上个状态可直接一步计算）

**伪代码**

```python

n = length[T]
m = length[P]
hp = hash(P)

for s = 0 to n - m
  hs = hash(T[s..s+m])
  if hp == hs and double check is right
    save info
```

![示意图](https://tva1.sinaimg.cn/large/0081Kckwly1glwvk2z36jj31y40kkdi3.jpg)

我们这里选取的哈希函数为

$f(P)=P$表示的 10 进制值

假设$P$和$T$全由$d$个字符组成的，则我们可以选择$d$进制表示$P$和$T$，再将$d$进制转为$10$进制便于计算。
为了简化说明，我们更特殊的假设$P$和$T$全由[0-9]10 个数字组成。
$P$的 10 进制为：

```
f(P) = P[0] * 10 ^ (m - 1) + P[1] * 10 ^ (m - 2) ... + P[1]
```

$T[s..s+m]$的 10 进制为:

```
f(T[s..s + m]) = T[s] * 10 ^ (m - 1) + T[s + 1] * 10 ^ (m - 2) ... + T[s + m]
```

$T[s+1..s+m+1]$可以根据$T[s..s+m]$推导

```
f(T[s+1..s + m + 1]) = T[s+1] * 10 ^ (m - 1) + T[s + 2] * 10 ^ (m - 2) ... + T[s + m + 1]
= (f(T[s..s + m]) - T[s] * 10 ^ (m - 1)) * 10 + T[s + m + 1]
```

这样就把以上 `hp === hs` 的哈希比较转化为正常的 10 进制比较。

到目前为止，以上假设我们回避的一个问题是如果$f(P)$或者$f(T)$计算的 10 进制过大，导致运算溢出怎么办？

这里我们通过选择一个比较大的素数$q$, 计算后的 10 进制数对$q$取模后再进行比较。但是这种方案并不完美，$f(P)%q==f(T[s])%q$并不能代表$f(P)==f(T[s])$。任何的$f(P)%q===f(T[s])%q$都需要额外进行再次验证, 这里我们通过检测$P==T[s..s+m]$来完成。

## KMP

**KMP 本质上是个预处理 + dp。**

- 预处理指的是经过这样的处理一个模式串会生成一个 next 数组，从而可以去匹配任意的主串。
- dp 指的是建立 next 数组的部分使用到了动态规划的算法。

而匹配的过程，BF 算法中主串会有很多回溯，使用 KMP 可以避免主串回溯，而只回溯模式串。 形象地看就是模式串不停地在对齐主串。

**核心思路**

首先我们定义模式串的前缀函数 f(i) 为 模式串 P 中 P[1...i]相同前缀后缀的最大长度。对 P[1...m]中的每个 i，(i > 0 && i <= m), 用一个数组 next 记录。
KMP 算法由 Knuth，Morris 和 Pratt 三个大佬联合发明，KMP 算法名字由三个大佬名字首位字符组成。

首先我们定义模式串的函数$f(i)$为模式串$P$中$P[:i]$相同前缀后缀的最大长度。对$P$中的每个$i$的信息，用一个数组$next$统一记录。
KMP 算法在每次失配后，会根据上一次的比对信息跳转到相应的$s$处，借助的就是上述的$next$数组。
推导过程可以参考 [从头到尾彻底理解 KMP](https://blog.csdn.net/v_JULY_v/article/details/7041827)，个人觉得这篇讲的非常透彻，这里就不班门弄斧了。
该方法可以抽象为以下几步：

- 非法情况处理，如模式串长度大于待匹配串等（防御性编程）
- 计算出模式串的 next 数组。
- 开始从待匹配串开始进行匹配
- 若匹配成功，则记录相关信息；若失配，则按 next 数组回退到上一个待匹配状态继续进行匹配

以下是计算$next$数组的伪代码

```python

get_next(P):
  m  = P.length
  使得 next 为长度为m的数组
  next[1] = 0
  k = 0
  for i = 2 to m
    while(k > 0 并且 P[k+1] != P[i])
      k = next[k]
    if P[k+1] == P[i]
      k = k + 1
    next[i] = k
  return next
```

以下是 KMP 的伪代码

```python
KMP(T, P)
  n = T.length
  m = P.length
  next = getNext(P)
  q = 0
  for let i = 1 to n:
    while(q > 0 并且 P[q + 1] !== T[i])
      q = next[q]
    if P[q + 1] == T[i]
      q = q + 1
    if (q == m)
      找到匹配位移 s = i
```

## 基于有限自动机的字符串匹配

这个算法仅限了解即可，这里不做展开，感兴趣可以参考 [Finite Automata algorithm for Pattern Searching](https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching/)

## 推荐学习视频(需翻墙)

[油管 KMP 讲解](https://www.youtube.com/watch?v=GTJr8OvyEVQ)

## 参考

- [维基百科](https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95)
- [从头到尾彻底理解 KMP](https://blog.csdn.net/v_JULY_v/article/details/7041827)
- [Finite Automata algorithm for Pattern Searching](https://www.geeksforgeeks.org/finite-automata-algorithm-for-pattern-searching/)
